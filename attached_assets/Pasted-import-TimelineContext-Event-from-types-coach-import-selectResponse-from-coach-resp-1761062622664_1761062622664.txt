import { TimelineContext, Event } from '@/types/coach';
import { selectResponse } from '@/coach/responseService';
import { beepCtl, scheduleCountdownBeeps, scheduleRestToWorkBeeps, workEndBeep } from '@/coach/beeps';

const ALLOW_VOICE_OVER_BEEP = true; // voice may overlap beeps if true
let speaking = false;
const speakQueue: Array<{ text: string }> = [];
let pendingWorkEndTimer: ReturnType<typeof setTimeout> | null = null;

function passesChatterGate(ctx: TimelineContext): boolean { return ctx.chatterLevel !== 'silent'; }
function scheduleAt(secFromNow: number, fn: ()=>void){ if (secFromNow <= 0) return fn(); setTimeout(fn, secFromNow * 1000); }

function processSpeakQueue(ctx: TimelineContext){
  if (speaking || speakQueue.length === 0) return;
  speaking = true;
  const { text } = speakQueue.shift()!;
  ctx.caption?.(text);
  const start = () => { ctx.speak?.(text); setTimeout(() => { speaking = false; processSpeakQueue(ctx); }, 1500); };
  const now = ctx.nowMs();
  if (!ALLOW_VOICE_OVER_BEEP && now < beepCtl.muteUntil) setTimeout(start, beepCtl.muteUntil - now);
  else start();
}
function say(ctx: TimelineContext, line: string){ speakQueue.push({ text: line }); processSpeakQueue(ctx); }

function synthesizePromptLine(ctx: TimelineContext, ev: Event): string | null {
  switch (ev.type) {
    case 'EV_BLOCK_START': return 'Block starting — set up now.';
    case 'EV_COUNTDOWN': return `Start in ${(ev.sec ?? 3)}…`;
    case 'EV_WORK_START': {
      const si = (ev as any).setIndex; const ts = (ev as any).totalSets;
      const name = ctx.getExerciseName((ev as any).exerciseId);
      if (typeof si === 'number' && typeof ts === 'number') {
        if (si === 0) return `Set one — ${name}.`;
        if (si === ts - 1) return `Final set — ${name}.`;
        return `Set ${si + 1} — ${name}.`;
      }
      return `Go — ${name}.`;
    }
    case 'EV_WORK_END': return 'Nice work — breathe.';
    case 'EV_REST_START': return 'Rest — log your set.';
    case 'EV_REST_END': return 'Rest over. Lock in.';
    case 'EV_ROUND_REST_START': return 'Round rest — reset and get set.';
    case 'EV_BLOCK_END': return 'Block complete — log your weights.';
    default: return null;
  }
}

export function onEvent(ctx: TimelineContext, ev: Event) {
  // Ready gate
  if (ev.type === 'EV_AWAIT_READY') { ctx.showReadyModal?.(); return; }

  // Local beeps
  if (ev.type === 'EV_COUNTDOWN' && typeof ev.sec === 'number' && ev.sec <= 5) {
    scheduleCountdownBeeps(scheduleAt, ctx, ev.sec);
  }
  if (ev.type === 'EV_REST_START' && typeof ev.sec === 'number') {
    scheduleRestToWorkBeeps(scheduleAt, ctx, ev.sec);
  }
  if (ev.type === 'EV_WORK_END') {
    workEndBeep(ctx); // long beep at work end
  }

  if (!passesChatterGate(ctx)) return; // silent mode

  // Coalesce: prefer REST_START over WORK_END when both arrive together
  if (ev.type === 'EV_WORK_END') {
    const line = selectResponse(ctx, ev) ?? synthesizePromptLine(ctx, ev);
    if (!line) return;
    pendingWorkEndTimer = setTimeout(() => { say(ctx, line); pendingWorkEndTimer = null; }, 120);
    return;
  }
  if (ev.type === 'EV_REST_START') {
    if (pendingWorkEndTimer) { clearTimeout(pendingWorkEndTimer); pendingWorkEndTimer = null; }
    const line = selectResponse(ctx, ev) ?? synthesizePromptLine(ctx, ev);
    if (line) say(ctx, line);
    return;
  }

  const line = selectResponse(ctx, ev) ?? synthesizePromptLine(ctx, ev);
  if (line) say(ctx, line);
}
