SuprSet Coach Starter Code (v1.1) — Replit Drop‑in

Files are organized as logical modules to paste into your codebase. Replace imports (e.g., UI components) as needed.

⸻

/types/coach.ts

export type Pattern = 'superset'|'straight_sets'|'circuit'|'custom';
export type Mode = 'time'|'reps';
export type ChatterLevel = 'silent'|'signals'|'minimal'|'standard'|'high';

export interface BlockParams {
  pattern: Pattern;
  mode: Mode;
  awaitReadyBeforeStart?: boolean; // default false
  partnerAlt?: boolean;
  restBetweenPartnersSec?: number;  // default 0
  speakCountdownSec?: number;       // default 3
  safety?: { maxRPE?: number; allowPainProceed?: boolean };
  chatterLevel?: ChatterLevel;      // default 'minimal'
}

export interface WorkoutPrefs {
  preflightLoadIntake: boolean;     // default true
  strictEMOM: boolean;              // default true
  allowAutoExtendRest: false;       // per decision
  rpeLabels: 'words'|'numbers'|'both'; // default 'words'
}

export type Event =
  | { type:'EV_BLOCK_START'; blockId:string }
  | { type:'EV_AWAIT_READY'; blockId:string }
  | { type:'EV_COUNTDOWN'; sec:number }
  | { type:'EV_WORK_START'; exerciseId:string }
  | { type:'EV_WORK_END'; exerciseId:string }
  | { type:'EV_REST_START'; sec:number; reason?:string }
  | { type:'EV_REST_END' }
  | { type:'EV_ROUND_REST_START'; sec:number }
  | { type:'EV_ROUND_REST_END' }
  | { type:'EV_BLOCK_END'; blockId:string }
  | { type:'EV_WORKOUT_END' };

export interface TimelineContext {
  workoutId: string;
  blockId?: string;
  pattern: Pattern;
  mode: Mode;
  chatterLevel: ChatterLevel;
  prefs: WorkoutPrefs;
  nowMs(): number;
  // data hooks
  getExerciseName(id:string): string;
  getNextExerciseName?(id?:string): string | undefined;
  plannedLoads: Record<string, number | undefined>; // per exerciseId (kg)
  // ui/system hooks (to be implemented in app)
  showReadyModal?: () => Promise<void>;
  openRestQuickLog?: (exerciseId:string) => void;
  speak?: (text:string) => void;
  beep?: (kind:'start'|'last5'|'end'|'countdown'|'confirm') => void;
  caption?: (text:string) => void;
  haptic?: (kind:'light'|'medium'|'heavy') => void;
}


⸻

/coach/responseService.ts

import { TimelineContext, Event } from '@/types/coach';

export interface CoachResponse {
  id: number;
  event_type: string;   // e.g., 'pre_block','countdown','work_start','last5s','rest_start','round_rest','block_end'
  pattern: string;      // specific or 'any'
  mode: string;         // 'time'|'reps'|'any'
  chatter_level: string;// level or 'any'
  locale: string;       // 'en-US'
  text_template: string;// tokens: {{exercise}}, {{next}}, {{restSec}}, {{loadDelta}}, {{count}}, {{sets}}
  priority: number;     // 1..5
  cooldown_sec: number; // 0..n
  active: boolean;
  usage_count: number;
  last_used_at: number | null; // epoch ms
}

// TODO: wire to real DB. Minimal in-memory adapter for now.
let _pool: CoachResponse[] = [];
export function seedResponses(rows: CoachResponse[]) { _pool = rows; }

function mapEvent(ev: Event): string {
  switch (ev.type) {
    case 'EV_BLOCK_START': return 'pre_block';
    case 'EV_COUNTDOWN': return 'countdown';
    case 'EV_WORK_START': return 'work_start';
    case 'EV_WORK_END': return 'work_end';
    case 'EV_REST_START': return 'rest_start';
    case 'EV_ROUND_REST_START': return 'round_rest';
    case 'EV_BLOCK_END': return 'block_end';
    default: return 'misc';
  }
}

function inCooldown(r: CoachResponse, now: number): boolean {
  if (!r.last_used_at) return false;
  return now - r.last_used_at < r.cooldown_sec * 1000;
}

function fit(r: CoachResponse, ctx: TimelineContext, ev: Event): boolean {
  if (!r.active) return false;
  const e = mapEvent(ev);
  const matchEvent = r.event_type === e;
  const matchPattern = r.pattern === 'any' || r.pattern === ctx.pattern;
  const matchMode = r.mode === 'any' || r.mode === ctx.mode;
  const matchChat = r.chatter_level === 'any' || r.chatter_level === ctx.chatterLevel;
  return matchEvent && matchPattern && matchMode && matchChat;
}

function prioritize(rows: CoachResponse[]): CoachResponse | null {
  if (!rows.length) return null;
  // Higher priority first, then lower usage_count
  return rows.sort((a,b) => (b.priority - a.priority) || (a.usage_count - b.usage_count))[0];
}

function renderTemplate(tpl: string, ctx: TimelineContext, ev: Event): string {
  const tokens: Record<string, string | number> = {
    exercise: (ev as any).exerciseId ? ctx.getExerciseName((ev as any).exerciseId) : '',
    next: ctx.getNextExerciseName ? (ctx.getNextExerciseName() || '') : '',
    restSec: (ev as any).sec ?? '',
    count: (ev as any).sec ?? '',
    sets: '',
    loadDelta: ''
  };
  return tpl.replace(/\{\{(\w+)\}\}/g, (_, k) => String(tokens[k] ?? ''));
}

export function selectResponse(ctx: TimelineContext, ev: Event): string | null {
  const now = ctx.nowMs();
  const candidates = _pool.filter(r => fit(r, ctx, ev) && !inCooldown(r, now));
  const pick = prioritize(candidates);
  if (!pick) return null;
  pick.usage_count += 1;
  pick.last_used_at = now;
  return renderTemplate(pick.text_template, ctx, ev);
}


⸻

/coach/observer.ts

import { TimelineContext, Event } from '@/types/coach';
import { selectResponse } from '@/coach/responseService';

function passesChatterGate(ctx: TimelineContext): boolean {
  return ctx.chatterLevel !== 'silent';
}

function speakOrSignal(ctx: TimelineContext, line: string) {
  if (ctx.chatterLevel === 'signals') {
    // minimal audio cues only
    ctx.caption?.(line);
    ctx.haptic?.('light');
    return;
  }
  ctx.caption?.(line);
  ctx.speak?.(line);
}

function synthesizePromptLine(ctx: TimelineContext, ev: Event): string | null {
  // Tier‑1 fallback: short, deterministic, event‑aware lines
  switch (ev.type) {
    case 'EV_BLOCK_START': return 'Block starting — set up now.';
    case 'EV_COUNTDOWN': return `Start in ${(ev.sec ?? 3)}…`;
    case 'EV_WORK_START': return 'Go — one clean form cue.';
    case 'EV_WORK_END': return 'Nice work — breathe.';
    case 'EV_REST_START': return 'Rest — log your set.';
    case 'EV_ROUND_REST_START': return 'Round rest — reset and get set.';
    case 'EV_BLOCK_END': return 'Block complete — next block up.';
    default: return null;
  }
}

export function onEvent(ctx: TimelineContext, ev: Event) {
  // Ready gates
  if (ev.type === 'EV_AWAIT_READY') {
    ctx.showReadyModal && ctx.showReadyModal();
    return; // UI will resume timeline
  }

  // EMOM strictness is enforced by the timeline builder; observer keeps cues tight
  if (!passesChatterGate(ctx)) return;

  const line = selectResponse(ctx, ev) ?? synthesizePromptLine(ctx, ev);
  if (!line) return;
  // throttle policy can live here if needed (e.g., 1 cue / 5s)
  speakOrSignal(ctx, line);

  // Open logging UI at rest start
  if (ev.type === 'EV_REST_START' && ctx.openRestQuickLog && (ctx.mode === 'reps')) {
    // In rep‑mode we log during rest
    // If partnerAlt is used, caller will pass the active exerciseId in a separate event or context
    // Here we assume EV_WORK_END carried it previously; app can store it on ctx
  }
}


⸻

/components/PreflightWeightsSheet.tsx

import React, { useMemo, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

type ExerciseRow = { id: string; name: string };

export function PreflightWeightsSheet({
  exercises,
  lastLoads,
  onSave,
  onCancel
}: {
  exercises: ExerciseRow[];
  lastLoads: Record<string, number | undefined>;
  onSave: (planned: Record<string, number | undefined>) => void;
  onCancel?: () => void;
}) {
  const [planned, setPlanned] = useState<Record<string, number | undefined>>(() => ({ ...lastLoads }));

  const rows = useMemo(() => exercises, [exercises]);

  const setLoad = (id: string, v: string) => {
    const n = v === '' ? undefined : Number(v);
    setPlanned(p => ({ ...p, [id]: Number.isFinite(n!) ? n : undefined }));
  };

  const useLast = (id: string) => setPlanned(p => ({ ...p, [id]: lastLoads[id] }));

  return (
    <Card className="w-full max-w-2xl">
      <CardHeader>
        <CardTitle>Set your working weights</CardTitle>
      </CardHeader>
      <CardContent className="space-y-3">
        {rows.map(r => (
          <div key={r.id} className="grid grid-cols-12 items-center gap-2">
            <div className="col-span-6 truncate">{r.name}</div>
            <div className="col-span-3">
              <Input
                inputMode="decimal"
                value={planned[r.id] ?? ''}
                placeholder={lastLoads[r.id] ? String(lastLoads[r.id]) : 'kg'}
                onChange={e => setLoad(r.id, e.target.value)}
              />
            </div>
            <div className="col-span-3 flex justify-end">
              <Button variant="outline" size="sm" onClick={() => useLast(r.id)}>Use last</Button>
            </div>
          </div>
        ))}
        <div className="flex justify-end gap-2 pt-4">
          {onCancel && <Button variant="ghost" onClick={onCancel}>Cancel</Button>}
          <Button onClick={() => onSave(planned)}>Save & Continue</Button>
        </div>
      </CardContent>
    </Card>
  );
}


⸻

/components/RestQuickLogCard.tsx

import React, { useState } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Toggle } from '@/components/ui/toggle';

export function RestQuickLogCard({
  exerciseName,
  defaultReps,
  defaultLoad,
  defaultRPE = 'Moderate',
  defaultPain = false,
  onUseLast,
  onSubmit
}: {
  exerciseName: string;
  defaultReps?: number;
  defaultLoad?: number;
  defaultRPE?: 'Easy'|'Moderate'|'Hard';
  defaultPain?: boolean;
  onUseLast: () => void;
  onSubmit: (payload: { reps?: number; load?: number; rpe: 'Easy'|'Moderate'|'Hard'; pain: boolean }) => void;
}) {
  const [reps, setReps] = useState<number | undefined>(defaultReps);
  const [load, setLoad] = useState<number | undefined>(defaultLoad);
  const [rpe, setRpe] = useState<'Easy'|'Moderate'|'Hard'>(defaultRPE);
  const [pain, setPain] = useState<boolean>(defaultPain);

  return (
    <Card className="w-full">
      <CardContent className="space-y-3 pt-4">
        <div className="text-sm text-muted-foreground">{exerciseName}</div>
        <div className="grid grid-cols-12 gap-2 items-center">
          <div className="col-span-3">
            <Input inputMode="numeric" placeholder="Reps" value={reps ?? ''} onChange={e => setReps(e.target.value ? Number(e.target.value) : undefined)} />
          </div>
          <div className="col-span-3">
            <Input inputMode="decimal" placeholder="Load (kg)" value={load ?? ''} onChange={e => setLoad(e.target.value ? Number(e.target.value) : undefined)} />
          </div>
          <div className="col-span-4 flex gap-1">
            {(['Easy','Moderate','Hard'] as const).map(level => (
              <Button key={level} variant={rpe===level? 'default':'outline'} size="sm" onClick={() => setRpe(level)}>
                {level}
              </Button>
            ))}
          </div>
          <div className="col-span-2 flex justify-end">
            <Toggle pressed={pain} onPressedChange={setPain}>Pain</Toggle>
          </div>
        </div>
        <div className="flex justify-between pt-2">
          <Button variant="ghost" onClick={onUseLast}>Use last set values</Button>
          <Button onClick={() => onSubmit({ reps, load, rpe, pain })}>Save</Button>
        </div>
      </CardContent>
    </Card>
  );
}


⸻

/db/seedCoachResponses.sql

CREATE TABLE IF NOT EXISTS coach_responses (
  id SERIAL PRIMARY KEY,
  event_type TEXT NOT NULL,
  pattern TEXT DEFAULT 'any',
  mode TEXT DEFAULT 'any',
  chatter_level TEXT DEFAULT 'any',
  locale TEXT DEFAULT 'en-US',
  text_template TEXT NOT NULL,
  priority INT DEFAULT 3,
  cooldown_sec INT DEFAULT 30,
  active BOOLEAN DEFAULT TRUE,
  usage_count INT DEFAULT 0,
  last_used_at TIMESTAMP NULL
);

INSERT INTO coach_responses (event_type, pattern, mode, chatter_level, text_template, priority) VALUES
('pre_block','any','reps','minimal','Superset: {{exercise}} then {{next}} — {{sets}} sets, {{restSec}}s rest. Set 1 in {{count}}…',4),
('last5s','any','time','minimal','Last five — finish clean, breathe.',3),
('rest_start','any','reps','minimal','Nice set. Log reps & load; tap “Use last values” if unchanged.',5);


⸻

Notes
	•	Hook observer.onEvent into your existing ExecutionTimeline event bus.
	•	Replace UI imports with your design system if different (we used shadcn/ui placeholders).
	•	The response service uses an in‑memory pool; swap with real DB queries when ready.
	•	EMOM strictness remains a timeline responsibility; the observer only cues.

⸻

Wiring Snippet — Hook onEvent(ctx, ev) + Preflight Mount (tiny)

Minimal example showing: 1) mounting PreflightWeightsSheet before Begin Workout, and 2) wiring your ExecutionTimeline emitter to the Coach observer.

/player/WorkoutPlayer.tsx

import React, { useEffect, useMemo, useRef, useState } from 'react';
import { onEvent } from '@/coach/observer';
import { seedResponses } from '@/coach/responseService';
import { PreflightWeightsSheet } from '@/components/PreflightWeightsSheet';
import type { TimelineContext, ChatterLevel } from '@/types/coach';
import { ExecutionTimeline } from '@/runtime/executionTimeline'; // your emitter

export function WorkoutPlayer({ workout, blocks, exercises, lastLoads }:{
  workout: { id: string };
  blocks: Array<{ id: string; params: { pattern:'superset'|'straight_sets'|'circuit'|'custom'; mode:'time'|'reps'; awaitReadyBeforeStart?: boolean } }>;
  exercises: Array<{ id: string; name: string }>;
  lastLoads: Record<string, number|undefined>;
}) {
  const [planned, setPlanned] = useState<Record<string, number|undefined>>({});
  const [stage, setStage] = useState<'preflight'|'playing'>('preflight');
  const chatterLevel: ChatterLevel = 'minimal';

  // Build a TimelineContext the observer can use
  const ctx = useMemo<TimelineContext>(() => ({
    workoutId: workout.id,
    pattern: blocks[0]?.params.pattern ?? 'straight_sets',
    mode: blocks[0]?.params.mode ?? 'reps',
    chatterLevel,
    prefs: { preflightLoadIntake: true, strictEMOM: true, allowAutoExtendRest: false, rpeLabels: 'words' },
    plannedLoads: planned,
    nowMs: () => Date.now(),
    getExerciseName: (id) => exercises.find(e => e.id === id)?.name || 'Exercise',
    getNextExerciseName: () => undefined,
    // Minimal UI hooks
    showReadyModal: () => new Promise<void>(res => { if (window.confirm('Ready?')) res(); }),
    speak: (t) => console.log('[COACH]', t),
    caption: (t) => console.log('[CAPTION]', t),
    haptic: () => {}
  }), [workout.id, blocks, planned, exercises, chatterLevel]);

  // (Optional) seed a couple response lines (Tier‑2) so you see variety immediately
  useEffect(() => {
    seedResponses([
      { id:1,event_type:'pre_block',pattern:'any',mode:'any',chatter_level:'minimal',locale:'en-US',text_template:'Block starting — set up now.',priority:4,cooldown_sec:10,active:true,usage_count:0,last_used_at:null },
      { id:2,event_type:'rest_start',pattern:'any',mode:'reps',chatter_level:'minimal',locale:'en-US',text_template:'Rest — log reps & load; tap “Use last values” if unchanged.',priority:5,cooldown_sec:10,active:true,usage_count:0,last_used_at:null }
    ] as any);
  }, []);

  // Wire the timeline emitter → observer
  const tlRef = useRef<ExecutionTimeline | null>(null);
  useEffect(() => {
    if (stage !== 'playing') return;
    const tl = new ExecutionTimeline();
    tlRef.current = tl;
    const unsub = tl.subscribe(ev => onEvent(ctx, ev));
    tl.start(blocks, { strictEMOM: true });
    return () => unsub();
  }, [stage, ctx, blocks]);

  if (stage === 'preflight') {
    return (
      <PreflightWeightsSheet
        exercises={exercises}
        lastLoads={lastLoads}
        onSave={(p) => { setPlanned(p); setStage('playing'); }}
      />
    );
  }
  return <div>▶️ Workout running… (see console for Coach output)</div>;
}

/runtime/executionTimeline.ts (super‑tiny demo emitter)

import type { Event } from '@/types/coach';

type Sub = (ev: Event) => void;
export class ExecutionTimeline {
  private subs: Sub[] = [];
  subscribe(fn: Sub){ this.subs.push(fn); return () => this.subs = this.subs.filter(s => s!==fn); }
  private emit(ev: Event){ this.subs.forEach(s => s(ev)); }

  start(blocks: Array<{id:string; params:{ awaitReadyBeforeStart?: boolean }}>, opts:{ strictEMOM: boolean }){
    const block = blocks[0];
    this.emit({ type:'EV_BLOCK_START', blockId:block.id });
    if (block.params.awaitReadyBeforeStart) {
      this.emit({ type:'EV_AWAIT_READY', blockId:block.id });
      // UI should call resumeAfterReady() when user confirms.
    } else {
      this.resumeAfterReady(block.id);
    }
  }

  resumeAfterReady(blockId: string){
    this.emit({ type:'EV_COUNTDOWN', sec:3 });
    setTimeout(() => {
      this.emit({ type:'EV_WORK_START', exerciseId:'ex-1' });
      setTimeout(() => {
        this.emit({ type:'EV_WORK_END', exerciseId:'ex-1' });
        this.emit({ type:'EV_REST_START', sec:90, reason:'between_sets' });
        // …continue emitting events per your compiled timeline
      }, 3000);
    }, 3000);
  }
}

That’s it:
	•	Mount PreflightWeightsSheet → onSave sets planned + flips stage to playing.
	•	Create ExecutionTimeline, subscribe with onEvent(ctx, ev), then start().
	•	If a block uses awaitReadyBeforeStart, call resumeAfterReady() after the Ready modal resolves.

⸻

/coach/beeps.ts

// /coach/beeps.ts — offline‑safe WebAudio beeps + optional voice ducking hook
export type BeepKind = 'countdown'|'start'|'last5'|'end'|'confirm';

type DuckFn = (on: boolean, ms: number) => void; // provided by voiceBus

class BeepEngine {
  private ctx?: AudioContext;
  private ducker: DuckFn | null = null;
  private F_SHORT = 880;    // Hz
  private F_LONG  = 660;    // Hz
  private DUR_SHORT = 0.22; // s
  private DUR_LONG  = 0.60; // s

  ensureCtx(){
    if (!this.ctx) this.ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
    return this.ctx;
  }
  setDucker(fn: DuckFn){ this.ducker = fn; }
  private duck(ms:number){ if (this.ducker) { try { this.ducker(true, ms); setTimeout(()=>this.ducker?.(false, ms), ms); } catch {} } }

  private tone(freq:number, dur:number){
    const ac = this.ensureCtx();
    const t0 = ac.currentTime;
    const osc = ac.createOscillator();
    const g = ac.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(0.85, t0 + 0.01);
    g.gain.linearRampToValueAtTime(0.85, t0 + dur - 0.05);
    g.gain.linearRampToValueAtTime(0.0, t0 + dur);
    osc.connect(g).connect(ac.destination);
    osc.start(t0); osc.stop(t0 + dur);
    this.duck(Math.round(dur * 1000));
  }
  private chirp(dur:number, f0:number, f1:number){
    const ac = this.ensureCtx();
    const t0 = ac.currentTime;
    const osc = ac.createOscillator();
    const g = ac.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(f0, t0);
    osc.frequency.linearRampToValueAtTime(f1, t0 + dur);
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(0.85, t0 + 0.01);
    g.gain.linearRampToValueAtTime(0.0, t0 + dur);
    osc.connect(g).connect(ac.destination);
    osc.start(t0); osc.stop(t0 + dur);
    this.duck(Math.round(dur * 1000));
  }

  play(kind: BeepKind){
    switch (kind){
      case 'countdown': return this.tone(this.F_SHORT, this.DUR_SHORT);
      case 'start':     return this.tone(this.F_LONG,  this.DUR_LONG);
      case 'last5':     return this.tone(this.F_SHORT, this.DUR_SHORT);
      case 'end':       return this.tone(this.F_LONG,  this.DUR_LONG);
      case 'confirm':   return this.chirp(0.18, 880, 1320);
    }
  }
  sequence(items: Array<{ atMs:number; kind: BeepKind }>): () => void {
    const tids: number[] = [];
    for (const it of items) tids.push(window.setTimeout(() => this.play(it.kind), Math.max(0, it.atMs)));
    return () => tids.forEach(clearTimeout);
  }
}

export const beeps = new BeepEngine();


⸻

/audio/voiceBus.ts

// /audio/voiceBus.ts — shared WebAudio gain bus for coach voice with smooth ducking
function dbToGain(db:number){ return Math.pow(10, db/20); }

class VoiceBus {
  private ac?: AudioContext;
  private voiceIn?: GainNode;
  private master?: GainNode;
  private lastBeepAt = 0;      // epoch ms
  private ttsCooldownMs = 250; // guard window

  ensure(){
    if (!this.ac){
      this.ac = new (window.AudioContext || (window as any).webkitAudioContext)();
      const ac = this.ac;
      this.voiceIn = ac.createGain();
      this.master  = ac.createGain();
      this.voiceIn.gain.value = 1.0;
      this.master.gain.value  = 1.0;
      this.voiceIn.connect(this.master).connect(ac.destination);
    }
    return this.ac!;
  }
  attachElement(el: HTMLAudioElement){
    const ac = this.ensure();
    const node = ac.createMediaElementSource(el);
    node.connect(this.voiceIn!);
  }
  attachStream(stream: MediaStream){
    const ac = this.ensure();
    const node = ac.createMediaStreamSource(stream);
    node.connect(this.voiceIn!);
  }
  setGainDb(db:number){
    this.ensure();
    const g = dbToGain(db);
    const t = this.ac!.currentTime;
    this.voiceIn!.gain.cancelScheduledValues(t);
    this.voiceIn!.gain.setTargetAtTime(g, t, 0.015);
  }
  duck(ms=250, depthDb=-6){
    this.ensure();
    const ac = this.ac!;
    const now = ac.currentTime;
    const target = dbToGain(depthDb);
    this.voiceIn!.gain.cancelScheduledValues(now);
    this.voiceIn!.gain.setTargetAtTime(target, now, 0.01);
    const releaseAt = now + Math.max(0.05, ms/1000);
    this.voiceIn!.gain.setTargetAtTime(1.0, releaseAt, 0.04);
    this.lastBeepAt = Date.now();
  }
  guardTTSStart<T>(fn: () => T, extraDelayMs=0): T | void {
    const since = Date.now() - this.lastBeepAt;
    const wait = Math.max(0, this.ttsCooldownMs - since) + extraDelayMs;
    if (wait <= 0) return fn();
    setTimeout(fn, wait);
  }
}

export const voiceBus = new VoiceBus();


⸻

/audio/ttsAdapter.ts

// /audio/ttsAdapter.ts — simple browser TTS adapter honoring the guard window
import { voiceBus } from '@/audio/voiceBus';

export function speakTTS(text: string){
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = 'en-US'; utter.rate = 1.0; utter.pitch = 1.0; utter.volume = 0.95;
  voiceBus.guardTTSStart(() => window.speechSynthesis.speak(utter));
}


⸻

Update /player/WorkoutPlayer.tsx (audio wiring)

// Add at top
import { beeps } from '@/coach/beeps';
import { voiceBus } from '@/audio/voiceBus';
import { speakTTS } from '@/audio/ttsAdapter';

// In component body (once) — unlock AudioContext on gesture (iOS)
React.useEffect(() => {
  const onFirst = () => { try { (voiceBus as any).ensure?.(); } catch {} };
  window.addEventListener('pointerdown', onFirst, { once: true });
  return () => window.removeEventListener('pointerdown', onFirst);
}, []);

// When building ctx in useMemo, set speak/beep:
const ctx = useMemo(() => ({
  // ...existing fields
  speak: (t: string) => speakTTS(t),
  beep:  (k: 'start'|'last5'|'end'|'countdown'|'confirm') => beeps.play(k),
  caption: (t: string) => console.log('%c[CAPTION]', 'color:#607d8b', t),
}), [/* deps */]);

// After imports, connect beeps → voice ducking (once per app)
beeps.setDucker((on, ms) => { if (on) voiceBus.duck(ms); });


⸻

/coach/roundBetweenScheduler.ts

// /coach/roundBetweenScheduler.ts — canonical between‑rounds timing for rep‑rounds
import type { TimelineContext } from '@/types/coach';

export type CancelFn = () => void;
export interface RoundBetweenOpts {
  ctx: TimelineContext;
  roundEndMs?: number;         // default Date.now()
  gapMs?: number;              // end → first countdown (default 3000)
  endBeepMs?: number;          // long beep dur (default 600)
  previewLeadMs?: number;      // speak preview before countdown (default 1000)
  nextRoundIndex?: number; totalRounds?: number;
  nextFirstExerciseId?: string;
  emit: (ev:any) => void;
  onPreview?: () => void;
  onGo?: () => void;
  emitCountdownEvents?: boolean;
}

export function scheduleRoundBetween(opts: RoundBetweenOpts): { cancel: CancelFn; goAtMs: number }{
  const { ctx, emit, onPreview, onGo, gapMs=3000, endBeepMs=600, previewLeadMs=1000,
          roundEndMs=Date.now(), nextRoundIndex, totalRounds, nextFirstExerciseId,
          emitCountdownEvents=false } = opts;
  const tids: number[] = [];
  const at = (ms:number, fn:()=>void) => { tids.push(window.setTimeout(fn, Math.max(0, ms))); };
  const cancel: CancelFn = () => tids.forEach(clearTimeout);

  // Round rest line after beep clears
  const restLineAt = roundEndMs + endBeepMs + 100;
  at(restLineAt - Date.now(), () => emit({ type:'EV_ROUND_REST_START', sec: Math.round(gapMs/1000) }));

  // Preview near start
  if (nextFirstExerciseId){
    const previewAt = roundEndMs + Math.max(200, gapMs - previewLeadMs);
    at(previewAt - Date.now(), () => {
      if (onPreview) return onPreview();
      emit({ type:'EV_WORK_PREVIEW', exerciseId: nextFirstExerciseId, roundIndex: nextRoundIndex, totalRounds });
    });
  }

  // Countdown pips, then GO
  const c1At = roundEndMs + gapMs;
  const c2At = c1At + 1000;
  const goAt = c1At + 2000;
  at(c1At - Date.now(), () => { ctx.beep?.('countdown'); if (emitCountdownEvents) emit({ type:'EV_COUNTDOWN', sec:3 }); });
  at(c2At - Date.now(), () => { ctx.beep?.('countdown'); if (emitCountdownEvents) emit({ type:'EV_COUNTDOWN', sec:2 }); });
  at(goAt - Date.now(), () => { ctx.beep?.('start'); onGo?.(); });

  return { cancel, goAtMs: goAt };
}


⸻

Usage snippet — rep‑round end handler

import { scheduleRoundBetween } from '@/coach/roundBetweenScheduler';

// after a round ends:
const { cancel, goAtMs } = scheduleRoundBetween({
  ctx,
  emit: (ev) => onEvent(ctx, ev),
  nextRoundIndex: roundIndex + 1,
  totalRounds: totalRounds,
  nextFirstExerciseId: exercises[0]?.id,
  onGo: () => setTimeout(() => onEvent(ctx, { type:'EV_WORK_START', exerciseId: exercises[0].id }), 220),
});

// If advancing early (user taps Round Done), call cancel() before scheduling the next between‑rounds.


⸻

DB + API Drop‑in — Coach Responses (production‑ready)

Purpose: swap from in‑memory seeds to a database‑backed response library with cooldowns, priorities, and usage tracking. Drizzle + Express (or your current server). Client falls back to seeds if API unavailable.

1) Drizzle schema — /db/schema/coachResponses.ts

// /db/schema/coachResponses.ts
import { pgTable, serial, varchar, text, boolean, integer, timestamp, index } from 'drizzle-orm/pg-core';

export const coachResponses = pgTable(
  'coach_responses',
  {
    id: serial('id').primaryKey(),
    eventType: varchar('event_type', { length: 32 }).notNull(),            // e.g., 'work_preview' | 'work_start' | 'last5s' | 'halfway' | 'rest_start'
    pattern: varchar('pattern', { length: 24 }).notNull().default('any'),  // 'superset' | 'straight_sets' | 'circuit' | 'emom' | 'amrap' | 'any'
    mode: varchar('mode', { length: 24 }).notNull().default('any'),        // 'time' | 'reps' | 'any'
    chatterLevel: varchar('chatter_level', { length: 16 }).notNull().default('minimal'), // 'silent'|'minimal'|'high'| 'any'
    locale: varchar('locale', { length: 8 }).notNull().default('en-US'),

    textTemplate: text('text_template').notNull(), // supports tokens: {{exercise}}, {{next_exercise}}, {{restSec}}, {{loadDelta}}

    priority: integer('priority').notNull().default(0),
    cooldownSec: integer('cooldown_sec').notNull().default(0),
    active: boolean('active').notNull().default(true),

    usageCount: integer('usage_count').notNull().default(0),
    lastUsedAt: timestamp('last_used_at', { withTimezone: false }),
    updatedAt: timestamp('updated_at', { withTimezone: false }).defaultNow(),
    createdAt: timestamp('created_at', { withTimezone: false }).defaultNow(),
  },
  (t) => ({
    byDims: index('coach_responses_dims_idx').on(
      t.eventType, t.pattern, t.mode, t.chatterLevel, t.locale, t.active
    ),
  })
);

export type CoachResponse = typeof coachResponses.$inferSelect;


⸻

2) SQL migration — /db/migrations/20251027_coach_responses.sql

CREATE TABLE IF NOT EXISTS coach_responses (
  id SERIAL PRIMARY KEY,
  event_type VARCHAR(32) NOT NULL,
  pattern VARCHAR(24) NOT NULL DEFAULT 'any',
  mode VARCHAR(24) NOT NULL DEFAULT 'any',
  chatter_level VARCHAR(16) NOT NULL DEFAULT 'minimal',
  locale VARCHAR(8) NOT NULL DEFAULT 'en-US',
  text_template TEXT NOT NULL,
  priority INTEGER NOT NULL DEFAULT 0,
  cooldown_sec INTEGER NOT NULL DEFAULT 0,
  active BOOLEAN NOT NULL DEFAULT TRUE,
  usage_count INTEGER NOT NULL DEFAULT 0,
  last_used_at TIMESTAMP NULL,
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS coach_responses_dims_idx
  ON coach_responses (event_type, pattern, mode, chatter_level, locale, active);

If you use Drizzle Kit, either run this file directly or generate an equivalent migration from the schema.

⸻

3) Seed runner — /scripts/seedCoachResponses.ts

// /scripts/seedCoachResponses.ts
// Loads SQL from db/seedCoachResponses.sql into the database.
import fs from 'node:fs/promises';
import path from 'node:path';
import { db } from '@/db/client';
import { sql } from 'drizzle-orm';

async function main(){
  const file = path.resolve(process.cwd(), 'db/seedCoachResponses.sql');
  const text = await fs.readFile(file, 'utf8');
  // optional: clear table first
  await db.execute(sql`TRUNCATE TABLE coach_responses RESTART IDENTITY;`);
  await db.execute(sql.raw(text));
  // sanity: count rows
  const rows = await db.execute(sql`SELECT COUNT(*) FROM coach_responses;`);
  // eslint-disable-next-line no-console
  console.log('[seed] coach_responses loaded:', rows);
}

main().catch((e) => { console.error(e); process.exit(1); });

Ensure your @/db/client exports a configured Drizzle instance.

⸻

4) API routes — Express version /server/routes/coachResponses.ts

// /server/routes/coachResponses.ts
import { Router } from 'express';
import { db } from '@/db/client';
import { coachResponses } from '@/db/schema/coachResponses';
import { and, eq, sql } from 'drizzle-orm';

const router = Router();

// GET /api/coach_responses?event_type=&pattern=&mode=&chatter_level=&locale=
router.get('/api/coach_responses', async (req, res) => {
  const {
    event_type, pattern = 'any', mode = 'any', chatter_level = 'minimal', locale = 'en-US'
  } = req.query as Record<string, string>;

  if (!event_type) return res.status(400).json({ error: 'event_type required' });

  // Pull active rows; cooldown applied client‑side using last_used_at if you prefer.
  const rows = await db
    .select()
    .from(coachResponses)
    .where(
      and(
        eq(coachResponses.active, true),
        eq(coachResponses.eventType, event_type),
        // loose matching: allow 'any' dimensions
        sql`(${coachResponses.pattern} = ${pattern} OR ${coachResponses.pattern} = 'any')`,
        sql`(${coachResponses.mode} = ${mode} OR ${coachResponses.mode} = 'any')`,
        sql`(${coachResponses.chatterLevel} = ${chatter_level} OR ${coachResponses.chatterLevel} = 'any')`,
        eq(coachResponses.locale, locale)
      )
    )
    .orderBy(coachResponses.priority);

  res.json({ items: rows });
});

// POST /api/coach_responses/:id/mark_used  { used_at?: string }
router.post('/api/coach_responses/:id/mark_used', async (req, res) => {
  const id = Number(req.params.id);
  const used_at = req.body?.used_at ? new Date(req.body.used_at) : new Date();
  await db.execute(sql`UPDATE coach_responses SET usage_count = usage_count + 1, last_used_at = ${used_at} WHERE id = ${id}`);
  res.json({ ok: true });
});

export default router;

Mount this in your server (e.g., /server/index.ts):

import coachResponsesRouter from '@/server/routes/coachResponses';
app.use(coachResponsesRouter);



Next.js API alternative: place same logic in app/api/coach_responses/route.ts and app/api/coach_responses/[id]/mark_used/route.ts using NextResponse.

⸻

5) Client — response API wrapper /coach/responseApi.ts

// /coach/responseApi.ts
export interface PoolQuery {
  event_type: string;
  pattern?: string;
  mode?: string;
  chatter_level?: string;
  locale?: string;
}

export interface PoolItem {
  id: number; textTemplate: string; priority: number; cooldownSec: number; lastUsedAt: string | null;
}

export async function fetchPool(q: PoolQuery): Promise<PoolItem[]> {
  const u = new URL('/api/coach_responses', window.location.origin);
  Object.entries({ ...q }).forEach(([k, v]) => v && u.searchParams.set(k, String(v)));
  const r = await fetch(u.toString(), { credentials: 'include' });
  if (!r.ok) throw new Error('fetchPool failed');
  const j = await r.json();
  return j.items as PoolItem[];
}

export async function markUsed(id: number){
  await fetch(`/api/coach_responses/${id}/mark_used`, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({}) });
}


⸻

6) Client — integrate with responseService /coach/responseService.ts (delta)

// /coach/responseService.ts (additions)
import { fetchPool, markUsed, PoolItem } from '@/coach/responseApi';

// Pick with cooldown + low-usage preference
function choose(items: PoolItem[], now = Date.now()): PoolItem | null {
  const ready = items.filter(it => {
    if (!it.lastUsedAt || !it.cooldownSec) return true;
    const last = new Date(it.lastUsedAt).getTime();
    return (now - last) / 1000 > it.cooldownSec;
  });
  if (!ready.length) return null;
  // sort by priority ASC, then by (usage_count asc) if present
  ready.sort((a,b) => a.priority - b.priority);
  return ready[0];
}

export async function getResponseFromDB(filters: { event_type: string; pattern: string; mode: string; chatter_level: string; locale: string; tokens: Record<string,string> }){
  try {
    const items = await fetchPool(filters);
    const pick = choose(items);
    if (!pick) return null;
    // simple token replacement
    let text = pick.textTemplate;
    Object.entries(filters.tokens || {}).forEach(([k,v]) => { text = text.replaceAll(`{{${k}}}`, v); });
    // fire and forget mark used
    markUsed(pick.id).catch(()=>{});
    return text;
  } catch {
    return null; // caller will fall back to in‑memory
  }
}


⸻

7) Player wiring (delta) — prefer DB, fallback to seeds

// Where you currently call selectResponse(...):
import { getResponseFromDB } from '@/coach/responseService';

async function selectCoachLine(ctx, ev, tokens){
  const dbText = await getResponseFromDB({
    event_type: mapEvent(ev.type),
    pattern: ctx.pattern ?? 'any',
    mode: ctx.mode ?? 'any',
    chatter_level: ctx.chatterLevel ?? 'minimal',
    locale: 'en-US',
    tokens
  });
  if (dbText) return dbText;
  // fallback to in‑memory pool (existing logic)
  return selectFromSeeds(ev, ctx, tokens);
}


⸻

8) Ops checklist
	•	Run migration: apply /db/migrations/20251027_coach_responses.sql.
	•	Execute seed: tsx scripts/seedCoachResponses.ts (or your runner).
	•	Mount routes: /server/routes/coachResponses.ts under /api.
	•	Flip Player to use getResponseFromDB with seed fallback.
	•	Verify cooldowns/priority ordering; watch usage_count increment.

Done. This completes the DB‑backed response library with minimal surface area. If you want Next.js API route variants, I can append them too.

⸻

Patch — Downstream Tech Hints (Rep‑Rounds) with Guards & Alternation

Implements the logic we agreed: High chatter adds one downstream technical cue per round (A2 preferred; A3 if A2 didn’t fire), with guardrails: Round ≥2, ≥70% confidence, ≥20s remaining, no beep collisions (guarded), and optional round alternation (A2 on odd, A3 on even).

1) New: /coach/cuePolicy.ts

// /coach/cuePolicy.ts — guard constants & simple policy helpers
export const CONF_THRESH = 0.70;         // ≥70% confidence to speak
export const MIN_REMAINING_SEC = 20;     // must have ≥20s left in round
export const TECH_OFFSET_MS = 3000;      // fire ~3s after window start
export const BEEP_GUARD_MS = 250;        // speech starts avoid ±250ms of beeps (handled by voiceBus.guard)
export const ALTERNATE_TECH_HINT = true; // if true: odd rounds→A2, even→A3 (1‑based)

export type ChatterLevel = 'silent'|'minimal'|'high';

export function allowDownstream(chatter: ChatterLevel, roundIndex: number){
  return chatter === 'high' && roundIndex >= 1; // R2+
}

export function preferA2ThisRound(roundIndex: number){
  if (!ALTERNATE_TECH_HINT) return true; // default to A2 if not alternating
  const round1Based = roundIndex + 1;
  return round1Based % 2 === 1; // odd→A2, even→A3
}

export function hasTimeRemaining(nowMs: number, roundEndMs: number){
  return (roundEndMs - nowMs) / 1000 >= MIN_REMAINING_SEC;
}

2) New: /coach/downstreamTech.ts

// /coach/downstreamTech.ts — schedules A2/A3 technical hints with guards
import { allowDownstream, preferA2ThisRound, hasTimeRemaining, CONF_THRESH, TECH_OFFSET_MS } from '@/coach/cuePolicy';
import type { TimelineContext } from '@/types/coach';

export interface DownstreamOpts {
  ctx: TimelineContext;               // has speak(), caption(), chatterLevel, nowMs()
  roundIndex: number;                 // 0‑based
  roundEndMs: number;                 // epoch ms when round ends (GO + roundDur)
  exerciseIds: { A1: string; A2?: string; A3?: string };
  windowsMs: { a2StartMs?: number; a3StartMs?: number }; // window starts (epoch ms)
  confidence: { a2?: number; a3?: number };              // 0..1
  getCue: (exerciseId: string) => string | null;          // returns a short tech cue (2–3 words)
  debug?: (msg: string) => void;                          // optional logger for HUD
}

export function scheduleDownstreamTech(opts: DownstreamOpts){
  const { ctx, roundIndex, roundEndMs, exerciseIds, windowsMs, confidence, getCue, debug } = opts;
  const tids: number[] = [];
  let fired = false;

  if (!allowDownstream((ctx.chatterLevel as any) ?? 'minimal', roundIndex)) {
    debug?.('[tech] skip: chatter!=high or round<R2');
    return () => tids.forEach(clearTimeout);
  }

  const tryFire = (exId?: string, label: 'A2'|'A3', conf?: number) => {
    if (!exId) { debug?.(`[tech] ${label} skip: missing exId`); return; }
    if (fired)  { debug?.(`[tech] ${label} skip: already fired this round`); return; }
    const now = ctx.nowMs ? ctx.nowMs() : Date.now();
    if ((conf ?? 0) < CONF_THRESH){ debug?.(`[tech] ${label} skip: conf ${(conf??0).toFixed(2)} < ${CONF_THRESH}`); return; }
    if (!hasTimeRemaining(now, roundEndMs)){ debug?.(`[tech] ${label} skip: <${MIN_REMAINING_SEC}s remaining`); return; }
    const cue = getCue(exId);
    if (!cue){ debug?.(`[tech] ${label} skip: no cue available`); return; }
    // Speak (voiceBus will guard near beeps; captions always on)
    ctx.caption?.(cue);
    ctx.speak?.(cue);
    debug?.(`[tech] ${label} fired: "${cue}"`);
    fired = true;
  };

  const preferA2 = preferA2ThisRound(roundIndex);

  // A2 slot
  if (windowsMs.a2StartMs){
    const at = Math.max(0, windowsMs.a2StartMs + TECH_OFFSET_MS - Date.now());
    tids.push(window.setTimeout(() => {
      if (preferA2) tryFire(exerciseIds.A2, 'A2', confidence.a2);
      else debug?.('[tech] A2 deferred by alternation');
    }, at));
  }

  // A3 slot — only fires if A2 didn’t, or if alternation prefers A3
  if (windowsMs.a3StartMs){
    const at = Math.max(0, windowsMs.a3StartMs + TECH_OFFSET_MS - Date.now());
    tids.push(window.setTimeout(() => {
      if (!fired) tryFire(exerciseIds.A3, 'A3', confidence.a3);
      else debug?.('[tech] A3 skip: A2 already fired');
    }, at));
  }

  return () => tids.forEach(clearTimeout);
}

3) Coach Lab integration (rep‑rounds) — minimal delta

In your rep‑round Lab page (e.g., /lab/coach-rep-round.tsx), after you compute the A1/A2/A3 window start times for the round, call the scheduler. Example:

import { scheduleRoundBetween } from '@/coach/roundBetweenScheduler';
import { scheduleDownstreamTech } from '@/coach/downstreamTech';

// inside your round orchestration logic:
const roundEndMs = goAtMs + roundDurMs; // you already know GO and round duration

// NOTE: these come from your pacing windows calculation
const a2StartMs = windows.A2.startMs; // epoch ms
const a3StartMs = windows.A3.startMs; // epoch ms

// Confidence — if you compute live confidence, pass it; else use heuristics (0.8 when present).
const confA2 = 0.8; const confA3 = 0.8;

// Speak preview/countdown via scheduleRoundBetween as you already do
const { cancel: cancelBetween } = scheduleRoundBetween({
  ctx,
  emit: (ev) => onEvent(ctx, ev),
  nextRoundIndex: roundIndex + 1,
  totalRounds,
  nextFirstExerciseId: exercises[0]?.id,
  onGo: () => setTimeout(() => onEvent(ctx, { type:'EV_WORK_START', exerciseId: exercises[0].id }), 220),
});

// Now schedule the downstream tech hint slots (High chatter only)
const cancelTech = scheduleDownstreamTech({
  ctx,
  roundIndex,
  roundEndMs,
  exerciseIds: { A1: exIds[0], A2: exIds[1], A3: exIds[2] },
  windowsMs: { a2StartMs, a3StartMs },
  confidence: { a2: confA2, a3: confA3 },
  getCue: (id) => getExerciseMeta(id)?.cues?.find(Boolean) ?? null,
  debug: (m) => console.log('%c[LAB]', 'color:#9c27b0', m),
});

// On round cancel/advance early, clear timers
return () => { cancelBetween(); cancelTech(); };

4) Optional: tiny HUD for visibility

If you want a simple on‑screen indicator in Lab, add a small HUD component that appends lines passed through the debug callback. This is optional and not needed in production.

⸻

Behavior summary now:
	•	Minimal: A1 start cue only (no downstream tech).
	•	High: A1 start + halfway; one downstream tech (A2 preferred; A3 if A2 didn’t fire or alternation prefers A3). Guards: R2+, ≥70% conf, ≥20s remaining.
	•	Voice starts near beeps are still protected by the existing voiceBus.guard.

⸻

Fix — Guard captions & Round‑1 preview timing (rep‑rounds)

This patch ensures no coach line lands inside 3‑2‑1 beeps and moves/suppresses the Round‑1 preview so it prints before the first pip. It also fixes the missing token case by skipping preview if the exercise name isn’t available.

1) Update /audio/voiceBus.ts — add a generic guard for any UI text

// ADD below existing methods
  guardStart<T>(fn: () => T, extraDelayMs = 0): T | void {
    const since = Date.now() - this.lastBeepAt;
    const wait = Math.max(0, this.ttsCooldownMs - since) + extraDelayMs;
    if (wait <= 0) return fn();
    setTimeout(fn, wait);
  }

  // Keep old name for TTS, route to generic guard
  guardTTSStart<T>(fn: () => T, extraDelayMs = 0): T | void {
    return this.guardStart(fn, extraDelayMs);
  }

2) New /ui/captionAdapter.ts — captions respect the beep guard

// /ui/captionAdapter.ts
import { voiceBus } from '@/audio/voiceBus';

export function makeGuardedCaption(print: (t: string) => void){
  return (t: string) => voiceBus.guardStart(() => print(t));
}

3) Update /player/WorkoutPlayer.tsx — use guarded captions

// imports
import { makeGuardedCaption } from '@/ui/captionAdapter';

// when building ctx
caption: makeGuardedCaption((t) => console.log('%c[CAPTION]', 'color:#607d8b', t)),

4) New /coach/roundOneScheduler.ts — schedule Round‑1 cleanly

// /coach/roundOneScheduler.ts — Round‑1: preview (optional) → 3‑2‑1 → GO
import type { TimelineContext } from '@/types/coach';

export interface RoundOneOpts {
  ctx: TimelineContext;
  goAtMs: number;                        // epoch ms for GO
  emit: (ev: any) => void;
  previewExerciseId?: string;            // A1
  enablePreview?: boolean;               // default false for Minimal
  previewLeadMs?: number;                // default 1000ms before first pip
  emitCountdownEvents?: boolean;         // captions for 3,2 (optional)
  onGo?: () => void;                     // fire A1 start cue ~200–300ms after GO
  totalRounds?: number;                  // optional
}

export function scheduleRoundOne(opts: RoundOneOpts){
  const { ctx, goAtMs, emit, previewExerciseId, enablePreview=false, previewLeadMs=1000, emitCountdownEvents=false, onGo } = opts;
  const tids: number[] = [];
  const at = (ms:number, fn:()=>void) => tids.push(window.setTimeout(fn, Math.max(0, ms)));

  // Countdown pips: -2000ms, -1000ms; GO at 0ms
  const c1At = goAtMs - 2000;
  const c2At = goAtMs - 1000;
  const previewAt = goAtMs - (2000 + previewLeadMs); // e.g., 1s before first pip

  // Optional preview (skip if no name)
  if (enablePreview && previewExerciseId){
    at(previewAt - Date.now(), () => {
      emit({ type:'EV_WORK_PREVIEW', exerciseId: previewExerciseId, roundIndex: 0, totalRounds: opts.totalRounds });
    });
  }

  at(c1At - Date.now(), () => { ctx.beep?.('countdown'); if (emitCountdownEvents) emit({ type:'EV_COUNTDOWN', sec: 3 }); });
  at(c2At - Date.now(), () => { ctx.beep?.('countdown'); if (emitCountdownEvents) emit({ type:'EV_COUNTDOWN', sec: 2 }); });
  at(goAtMs - Date.now(), () => { ctx.beep?.('start'); onGo?.(); });

  return () => tids.forEach(clearTimeout);
}

5) Rep‑round Lab — use Round‑1 scheduler & skip empty‑name preview

In /lab/coach-rep-round.tsx (or wherever you orchestrate Round‑1):

import { scheduleRoundOne } from '@/coach/roundOneScheduler';

// When the user hits Start (or after ready modal), decide GO time
const goAtMs = Date.now() + 3000; // initial 3s padding is typical

// Optional: only show Round‑1 preview on High chatter
const enablePreview = ctx.chatterLevel === 'high';
const a1Id = exercises[0]?.id;

const cancelR1 = scheduleRoundOne({
  ctx,
  emit: (ev) => onEvent(ctx, ev),
  goAtMs,
  previewExerciseId: a1Id,
  enablePreview: enablePreview && !!a1Id,
  onGo: () => setTimeout(() => onEvent(ctx, { type:'EV_WORK_START', exerciseId: a1Id }), 220),
});

// If user cancels/backs out, call cancelR1()

6) Observer safety — skip preview if we can’t resolve the name

Ensure your EV_WORK_PREVIEW handler gets the exercise name; if not, don’t speak or caption.

// in onEvent -> case 'EV_WORK_PREVIEW'
const name = ctx.getExerciseName?.(ev.exerciseId);
if (!name || !name.trim()) return; // skip — prevents "begin with ." cases
// otherwise render preview line from response pool / tokens

Acceptance (Round‑1):
	•	No caption/speech inside ±250ms of countdown beeps (guarded by voiceBus).
	•	Preview (if enabled) appears ≥1s before first pip.
	•	GO cue fires ~200–300ms after start beep.
	•	No empty exercise tokens in preview (skip if missing).

⸻

Phase 3 — Pre‑start “Workout Intro” (UI) — Paste‑ready drop‑in

Goal: explain how the workout runs before Start, computed from block/exercise params. Includes Chatter picker (Silent/Minimal/High), Pace picker for rep‑rounds, and Preflight Weights button for rep blocks. Integrates cleanly with the existing WorkoutPlayer stages.

1) New helper — /coach/introHelpers.ts

// /coach/introHelpers.ts — compute block cards (pattern/mode/duration/targets)
export type Pattern = 'superset'|'straight_sets'|'circuit'|'custom';
export type Mode = 'time'|'reps';

export interface BlockLike {
  id: string;
  name?: string;
  params: {
    pattern: Pattern;
    mode: Mode;
    setsPerExercise?: number;
    workSec?: number;
    restSec?: number;
    roundRestSec?: number;
    durationSec?: number;
    targetReps?: string; // e.g., "8-12"
    awaitReadyBeforeStart?: boolean;
  };
}

export interface ExerciseMeta { id: string; name: string }

function fmtSec(total: number){
  const m = Math.floor(total/60); const s = total%60;
  return m ? `${m}m${s? ` ${s}s`: ''}` : `${s}s`;
}
function clamp(n:number,min:number,max:number){ return Math.max(min, Math.min(max,n)); }

export function estimateBlockDurationSec(block: BlockLike, exCount: number, repPaceSec?: number): number {
  const p = block.params;
  if (p.durationSec && p.durationSec > 0) return p.durationSec;
  const sets = p.setsPerExercise ?? 1;
  if (p.mode === 'time'){
    const work = p.workSec ?? 0;
    const rest = p.restSec ?? 0;
    const roundRest = p.roundRestSec ?? 0;
    if (p.pattern === 'circuit'){
      const perRound = exCount * (work + rest);
      return sets * perRound + (sets > 1 ? (sets - 1) * roundRest : 0);
    }
    // straight or superset: do all sets per exercise before moving on
    // estimate as: exCount * sets * (work + rest)
    return exCount * sets * (work + rest);
  } else {
    // reps: rounds cadence * sets
    const pace = clamp(repPaceSec ?? 180, 90, 600);
    return (p.setsPerExercise ?? 1) * pace;
  }
}

export function patternLabel(p: Pattern){
  switch (p){
    case 'superset': return 'Superset';
    case 'straight_sets': return 'Straight Sets';
    case 'circuit': return 'Circuit';
    default: return 'Custom';
  }
}

export function modeLabel(m: Mode){ return m === 'time' ? 'Time' : 'Reps'; }

export function exerciseTargetsLine(block: BlockLike, ex: ExerciseMeta): string {
  const p = block.params;
  if (p.mode === 'time'){
    const work = p.workSec ?? 0; const rest = p.restSec ?? 0; const sets = p.setsPerExercise ?? 1;
    return `${ex.name} ${work}/${rest} ×${sets}`;
  } else {
    const reps = p.targetReps ?? '×';
    return `${ex.name} ${reps}`;
  }
}

export function blockSubtitle(block: BlockLike, exCount: number, repPaceSec?: number){
  const p = block.params;
  if (p.mode === 'time'){
    const work = p.workSec ?? 0; const rest = p.restSec ?? 0;
    if (p.pattern === 'circuit') return `${exCount} exercises • ${work}s work / ${rest}s rest`;
    return `${work}s on / ${rest}s off • all sets per exercise`;
  }
  const sets = p.setsPerExercise ?? 1;
  const pace = clamp(repPaceSec ?? 180, 90, 600);
  return `Superset ×${sets} rounds • cadence ${Math.floor(pace/60)}:${String(pace%60).padStart(2,'0')}`;
}

2) New component — /components/WorkoutIntroSheet.tsx

// /components/WorkoutIntroSheet.tsx — pre‑start overview & controls
import * as React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { patternLabel, modeLabel, estimateBlockDurationSec, blockSubtitle, exerciseTargetsLine } from '@/coach/introHelpers';

export type ChatterLevel = 'silent'|'minimal'|'high';

export interface WorkoutIntroProps {
  workoutTitle?: string;
  blocks: Array<{ id:string; name?:string; params:any; exerciseIds: string[] }>;
  exercises: Array<{ id:string; name:string }>
  defaultChatter?: ChatterLevel;
  defaultRepPaceSec?: number; // for rep‑round blocks
  onChangeChatter?: (c: ChatterLevel) => void;
  onChangeRepPace?: (sec: number) => void;
  onOpenPreflight?: () => void; // for rep blocks
  onBegin?: () => void;
}

export function WorkoutIntroSheet(props: WorkoutIntroProps){
  const { workoutTitle='Today\'s Workout', blocks, exercises, defaultChatter='minimal', defaultRepPaceSec=180, onChangeChatter, onChangeRepPace, onBegin, onOpenPreflight } = props;
  const [chatter, setChatter] = React.useState<ChatterLevel>(defaultChatter);
  const [pace, setPace] = React.useState<number>(defaultRepPaceSec);

  const getEx = (id:string) => exercises.find(e => e.id===id);

  // Compute total time
  const totalSec = blocks.reduce((acc,b) => {
    const exCount = b.exerciseIds.length;
    const sec = estimateBlockDurationSec({ id:b.id, params:b.params }, exCount, pace);
    return acc + sec;
  }, 0);

  const repBlocks = blocks.filter(b => b.params?.mode === 'reps');

  const paceOptions = [150, 180, 210, 240]; // 2:30, 3:00, 3:30, 4:00

  function start(){ onBegin?.(); }

  return (
    <div className="space-y-5">
      <header className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-semibold">{workoutTitle}</h2>
          <p className="text-sm text-muted-foreground">~{Math.round(totalSec/60)} min total</p>
        </div>
        <div className="flex items-center gap-2">
          <label className="text-sm">Chatter</label>
          <div className="flex rounded-lg border px-1 py-0.5 gap-1">
            {(['silent','minimal','high'] as ChatterLevel[]).map(v => (
              <button key={v} className={`px-2 py-1 rounded-md text-sm ${chatter===v?'bg-primary text-primary-foreground':'hover:bg-muted'}`} onClick={()=>{ setChatter(v); onChangeChatter?.(v); }}>{v[0].toUpperCase()+v.slice(1)}</button>
            ))}
          </div>
        </div>
      </header>

      {repBlocks.length>0 && (
        <section className="flex items-center gap-4">
          <div className="text-sm">
            <div className="font-medium">Pace (rep rounds)</div>
            <div className="text-muted-foreground">Choose your cadence per round</div>
          </div>
          <div className="flex rounded-lg border px-1 py-0.5 gap-1">
            {paceOptions.map(sec => (
              <button key={sec} className={`px-2 py-1 rounded-md text-sm ${pace===sec?'bg-primary text-primary-foreground':'hover:bg-muted'}`} onClick={()=>{ setPace(sec); onChangeRepPace?.(sec); }}>
                {Math.floor(sec/60)}:{String(sec%60).padStart(2,'0')}
              </button>
            ))}
          </div>
          <Button variant="outline" onClick={onOpenPreflight}>Preflight Weights</Button>
        </section>
      )}

      <section className="grid gap-4">
        {blocks.map((b, idx) => {
          const exCount = b.exerciseIds.length;
          const dur = estimateBlockDurationSec({ id:b.id, params:b.params }, exCount, pace);
          const title = `${String.fromCharCode(65+idx)}. ${patternLabel(b.params.pattern)} • ${modeLabel(b.params.mode)} • ${Math.round(dur/60)} min`;
          return (
            <Card key={b.id}>
              <CardHeader>
                <CardTitle className="flex items-center justify-between">
                  <span>{title}</span>
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-2">
                <p className="text-sm text-muted-foreground">{blockSubtitle({ id:b.id, params:b.params }, exCount, pace)}</p>
                <ul className="text-sm list-disc ml-5">
                  {b.exerciseIds.map(eid => {
                    const ex = getEx(eid); if (!ex) return null;
                    return <li key={eid}>{exerciseTargetsLine({ id:b.id, params:b.params }, ex)}</li>;
                  })}
                </ul>
                {b.params.awaitReadyBeforeStart && (
                  <p className="text-xs text-muted-foreground">Includes a ready check before starting.</p>
                )}
              </CardContent>
            </Card>
          );
        })}
      </section>

      <footer className="flex items-center justify-between pt-2">
        <p className="text-sm text-muted-foreground">Beeps guide timing; I’ll give brief form cues and collect load/reps during rest.</p>
        <Button size="lg" onClick={start}>Start Workout</Button>
      </footer>
    </div>
  );
}

3) Player integration — update /player/WorkoutPlayer.tsx

// /player/WorkoutPlayer.tsx (deltas only)
import { WorkoutIntroSheet } from '@/components/WorkoutIntroSheet';
import type { ChatterLevel } from '@/components/WorkoutIntroSheet';

// Add new stage value
const [stage, setStage] = useState<'intro'|'preflight'|'playing'>('intro');
const [chatterLevel, setChatterLevel] = useState<ChatterLevel>('minimal');
const [repPaceSec, setRepPaceSec] = useState<number>(180);

// When building ctx
const ctx = useMemo<TimelineContext>(() => ({
  // ...existing
  chatterLevel,
  prefs: { ...existingPrefs, repPaceSec },
  // ...
}), [/* deps incl. chatterLevel, repPaceSec */]);

// Render stages
if (stage === 'intro'){
  // derive blocks with exerciseIds for display; adapt to your data shape
  const displayBlocks = blocks.map(b => ({ id: b.id, params: b.params, exerciseIds: (b as any).exerciseIds ?? [] }));
  return (
    <WorkoutIntroSheet
      workoutTitle={`Workout ${workout.id}`}
      blocks={displayBlocks}
      exercises={exercises}
      defaultChatter={chatterLevel}
      defaultRepPaceSec={repPaceSec}
      onChangeChatter={setChatterLevel}
      onChangeRepPace={setRepPaceSec}
      onOpenPreflight={() => setStage('preflight')}
      onBegin={() => {
        // If there are any rep blocks and user wants preflight, route there first; else straight to playing
        const hasRep = blocks.some(b => b.params?.mode === 'reps');
        if (hasRep && ctx.prefs?.preflightLoadIntake) setStage('preflight');
        else setStage('playing');
      }}
    />
  );
}

if (stage === 'preflight'){
  return (
    <PreflightWeightsSheet
      exercises={exercises}
      lastLoads={lastLoads}
      onSave={(p) => { setPlanned(p); setStage('playing'); }}
    />
  );
}

Note: If your blocks do not carry exerciseIds, pass them from your compiler or fetch layer. The UI only needs names to render target lines.

4) Acceptance checklist
	•	Intro shows total time and one card per block with pattern, mode, duration, and exercise targets.
	•	Chatter picker changes ctx.chatterLevel immediately when the workout starts.
	•	Pace picker adjusts rep‑round duration and subtitle; persisted in ctx.prefs.repPaceSec.
	•	Preflight Weights button routes to existing preflight (rep blocks only).
	•	Start Workout begins the correct next stage: preflight (if enabled+rep blocks) or playing.

That’s the Phase‑3 UI wired. It’s computed—no free text—and matches the behavior we outlined. Copy these files and deltas into your project, and you’re good to test.

⸻

Phase 3 Merge — Lab → App Implementation Guide (paste‑ready)

Roll the Lab improvements into the production player with a simple feature flag. This replaces legacy countdown/preview code, adds block introductions, and wires rep‑round schedulers. Keep the Lab for iteration; main app becomes source of truth.

0) Prereqs — ensure these files exist (from earlier drops)
	•	/audio/voiceBus.ts (with guardStart/guardTTSStart, ducking)
	•	/coach/beeps.ts (softened pips + setSignalsVolume)
	•	/ui/captionAdapter.ts (guarded captions)
	•	/coach/roundOneScheduler.ts (R1: preview→3‑2‑1→GO)
	•	/coach/roundBetweenScheduler.ts (R2+: end→gap→3‑2‑1)
	•	/coach/cuePolicy.ts (constants + alternation)
	•	/coach/downstreamTech.ts (A2/A3 tech hints with guards)
	•	/coach/introHelpers.ts (duration/pattern strings)
	•	/components/WorkoutIntroSheet.tsx (pre‑start UI)
	•	DB pool (either your integrated shared/schema.ts + routes, or the Drop‑in section)

1) Feature flag (tiny)

Add a simple flag so you can revert:

// somewhere central, e.g., /config/flags.ts
export const FLAGS = {
  COACH_V2: (typeof window !== 'undefined' && new URLSearchParams(location.search).has('coachV2')) || true,
};

2) Emit block intros before countdown

In your production player (e.g., /pages/workout-session.tsx or /player/WorkoutPlayer.tsx), replace the legacy “start block” with:

import { buildBlockIntroLine } from '@/coach/introTokens'; // or inline compute via introHelpers

function beginBlock(blockIndex: number){
  const block = blocks[blockIndex];
  coachEmit({ type:'EV_BLOCK_START', blockId: block.id, meta: { pattern: block.params.pattern, mode: block.params.mode } });

  if (block.params?.awaitReadyBeforeStart){
    coachEmit({ type:'EV_AWAIT_READY', blockId: block.id });
    showReadyModal().then(() => startRoundOne(blockIndex));
  } else {
    startRoundOne(blockIndex);
  }
}

Observer handler (if not already):

case 'EV_BLOCK_START': {
  const b = blocks.find(x => x.id === ev.blockId);
  if (!b) break;
  const line = buildBlockIntroLine(b, exercises, ctx.prefs?.repPaceSec);
  if (line){ ctx.caption?.(line); ctx.speak?.(line); }
  break;
}

3) Round‑1 scheduler (rep‑rounds)

Replace any ad‑hoc R1 countdown logic with:

import { scheduleRoundOne } from '@/coach/roundOneScheduler';

function startRoundOne(blockIndex: number){
  const block = blocks[blockIndex];
  const isRep = block.params.mode === 'reps';
  if (!FLAGS.COACH_V2 || !isRep) return startTimeModeBlock(blockIndex); // your existing path

  const a1Id = block.exerciseIds?.[0];
  const goAtMs = Date.now() + 3000; // initial padding
  cancelRoundTimers?.();
  cancelRoundTimers = scheduleRoundOne({
    ctx,
    emit: (ev) => onEvent(ctx, ev),
    goAtMs,
    previewExerciseId: a1Id,
    enablePreview: ctx.chatterLevel === 'high' && !!a1Id,
    onGo: () => setTimeout(() => onEvent(ctx, { type:'EV_WORK_START', exerciseId: a1Id }), 220),
  });
}

4) Between‑rounds scheduler (rep‑rounds)

At each round end (your end‑beep emission point), schedule the next round countdown instead of starting immediately:

import { scheduleRoundBetween } from '@/coach/roundBetweenScheduler';

function onRoundComplete(blockIndex: number, roundIndex: number){
  const block = blocks[blockIndex];
  const next = roundIndex + 1;
  const total = block.params.setsPerExercise ?? 1;
  const firstId = block.exerciseIds?.[0];
  const { cancel } = scheduleRoundBetween({
    ctx,
    emit: (ev) => onEvent(ctx, ev),
    nextRoundIndex: next,
    totalRounds: total,
    nextFirstExerciseId: firstId,
    onGo: () => setTimeout(() => onEvent(ctx, { type:'EV_WORK_START', exerciseId: firstId }), 220),
  });
  // store cancel if you need to abort on pause/skip
}

This guarantees: end beep → 400ms gap → “round rest” line → 2.6s → countdown pips.

5) Preview/cue separation

During rest, near the end (e.g., ~1.2s before first pip), emit:

onEvent(ctx, { type: 'EV_WORK_PREVIEW', exerciseId: nextExerciseId, roundIndex, totalRounds });

At EV_WORK_START: Coach speaks cue‑only (no exercise name). Both routes are already guarded by voiceBus.guardStart via captionAdapter/ttsAdapter.

6) Downstream tech hint (High only)

When you compute A2/A3 window starts in the round, schedule the smart hint:

import { scheduleDownstreamTech } from '@/coach/downstreamTech';
const cancelTech = scheduleDownstreamTech({
  ctx,
  roundIndex, roundEndMs,
  exerciseIds: { A1: exIds[0], A2: exIds[1], A3: exIds[2] },
  windowsMs: { a2StartMs, a3StartMs },
  confidence: { a2: 0.8, a3: 0.8 },
  getCue: (id) => getExerciseMeta(id)?.cues?.find(Boolean) ?? null,
  debug: (m) => console.log('%c[TECH]', 'color:#9c27b0', m),
});

Rules enforced: R2+, ≥70% confidence, ≥20s remaining, no beep collisions, one hint per round (A2 preferred; A3 if A2 didn’t fire / alternation).

7) Intro Sheet → Player stages

Use the pre‑start sheet as entry point, then route to preflight (rep blocks) or straight to playing.

if (stage === 'intro'){
  return (
    <WorkoutIntroSheet
      blocks={blocks.map(b => ({ id:b.id, name:b.name, params:b.params, exerciseIds: b.exerciseIds }))}
      exercises={exercises}
      defaultChatter={chatterLevel}
      defaultRepPaceSec={repPaceSec}
      onChangeChatter={setChatterLevel}
      onChangeRepPace={setRepPaceSec}
      onOpenPreflight={() => setStage('preflight')}
      onBegin={() => {
        const hasRep = blocks.some(b => b.params?.mode==='reps');
        if (hasRep && ctx.prefs?.preflightLoadIntake) setStage('preflight');
        else setStage('playing');
      }}
    />
  );
}

8) Audio plumbing (confirm)
	•	ctx.beep(kind) → beeps.ts (softened tones) → voiceBus.duck(true/false)
	•	ctx.caption(text) → captionAdapter → voiceBus.guardStart
	•	ctx.speak(text) → ttsAdapter (or Realtime later) → voiceBus.guardTTSStart

9) DB response pool

Keep Replit’s integrated schema/routes. Ensure your observer prefers DB:

const line = await getResponseFromDB({...}) || selectFromSeeds(...);

Index should cover: (event_type, pattern, mode, chatter_level, locale, active).

10) Remove legacy overlaps
	•	Delete/disable any legacy code that starts countdown immediately after end beep (we now use roundBetweenScheduler).
	•	Remove any preview line that fires inside 3‑2‑1 (Round‑1 fix).

11) QA — pass/fail list
	•	R1: preview ≥1.0s before first pip; no speech in pips; GO cue ~+250ms.
	•	R2+: end beep → ~400ms → “round rest” line → ~2.6s → 3‑2‑1.
	•	Minimal: A1 start cue only; High: A1 start + halfway + one A2/A3 tech hint.
	•	EMOM/time blocks unchanged.
	•	Pause/Resume mid‑rest retains gaps and doesn’t double‑pip.
	•	Offline: beeps/timer keep running; speech delays/retries gracefully.

Ship behind COACH_V2. Once QA passes, flip the flag default to true.