import { TimelineContext, Event } from '@/types/coach';
import { selectResponse } from '@/coach/responseService';

const SPEAK_MIN_GAP_MS = 5000; // throttle
const COUNTDOWN_VOICE_OFF = true; // beeps handle countdown by default

let lastSpeakAt = 0;

function effectiveChatter(level: TimelineContext['chatterLevel']): 'silent'|'minimal'|'high' {
  // Collapse 5 → 3 tiers without breaking types
  if (level === 'silent' || level === 'signals') return 'silent';
  if (level === 'high' || level === 'standard') return 'high';
  return 'minimal';
}

function canSpeakNow(): boolean {
  const now = Date.now();
  if (now - lastSpeakAt < SPEAK_MIN_GAP_MS) return false;
  lastSpeakAt = now;
  return true;
}

function speak(ctx: TimelineContext, text: string) {
  ctx.caption?.(text);
  if (effectiveChatter(ctx.chatterLevel) === 'silent') return;
  ctx.speak?.(text);
}

function fallbackLine(ctx: TimelineContext, ev: Event): string | null {
  switch (ev.type) {
    case 'EV_BLOCK_START': return 'Block starting — set up now.';
    case 'EV_WORK_PREVIEW': {
      const name = ctx.getExerciseName((ev as any).exerciseId);
      const si = (ev as any).setIndex; const ri = (ev as any).roundIndex;
      if (typeof si === 'number') return `Set ${si+1} — ${name} coming up.`;
      if (typeof ri === 'number') return `Round ${ri+1} — ${name} next.`;
      return `${name} coming up.`;
    }
    case 'EV_WORK_START': return 'Go — one clean form cue.';
    case 'EV_HALFWAY':    return 'Halfway — keep your pace.';
    case 'EV_WORK_END':   return 'Nice work — breathe.';
    case 'EV_REST_START': return 'Rest — log your set.';
    case 'EV_ROUND_REST_START': return 'Round rest — reset and get set.';
    case 'EV_BLOCK_END':  return 'Block complete — next block up.';
    default: return null;
  }
}

export function onEvent(ctx: TimelineContext, ev: Event) {
  const tier = effectiveChatter(ctx.chatterLevel);

  // Ready gate
  if (ev.type === 'EV_AWAIT_READY') { ctx.showReadyModal?.(); return; }

  // Countdown voice policy
  if (ev.type === 'EV_COUNTDOWN' && COUNTDOWN_VOICE_OFF) {
    // UI handles beeps/captions; no voice
    return;
  }

  // Gate halfway: High chatter only
  if (ev.type === 'EV_HALFWAY' && tier !== 'high') return;

  // Silent tier: allow captions only via selectResponse/fallback below
  const line = selectResponse(ctx, ev) ?? fallbackLine(ctx, ev);
  if (!line) return;

  if (!canSpeakNow()) return;

  speak(ctx, line);
}
