import { TimelineContext, Event } from '@/types/coach';

export interface CoachResponse {
  id: number;
  event_type: string;   // 'pre_block','countdown','work_preview','work_start','halfway','last5s','rest_start','round_rest','block_end'
  pattern: string;      // specific or 'any'
  mode: string;         // 'time'|'reps'|'any'
  chatter_level: string;// level or 'any'
  locale: string;       // 'en-US'
  text_template: string;// tokens: {{exercise}}, {{next}}, {{restSec}}, {{cue}}, {{tempoCue}}, {{setNum}}, {{roundNum}}
  priority: number;
  cooldown_sec: number;
  active: boolean;
  usage_count: number;
  last_used_at: number | null;
}

let _pool: CoachResponse[] = [];
export function seedResponses(rows: CoachResponse[]) { _pool = rows; }

function mapEvent(ev: Event): string {
  switch (ev.type) {
    case 'EV_BLOCK_START': return 'pre_block';
    case 'EV_COUNTDOWN':   return 'countdown';
    case 'EV_WORK_PREVIEW':return 'work_preview';
    case 'EV_WORK_START':  return 'work_start';
    case 'EV_HALFWAY':     return 'halfway';
    case 'EV_WORK_END':    return 'work_end';
    case 'EV_REST_START':  return 'rest_start';
    case 'EV_ROUND_REST_START': return 'round_rest';
    case 'EV_BLOCK_END':   return 'block_end';
    default: return 'misc';
  }
}

function inCooldown(r: CoachResponse, now: number): boolean {
  if (!r.last_used_at) return false;
  return now - r.last_used_at < (r.cooldown_sec || 0) * 1000;
}

function fit(r: CoachResponse, ctx: TimelineContext, ev: Event): boolean {
  if (!r.active) return false;
  const e = mapEvent(ev);
  const matchEvent = r.event_type === e;
  const matchPattern = r.pattern === 'any' || r.pattern === ctx.pattern;
  const matchMode = r.mode === 'any' || r.mode === ctx.mode;
  const matchChat = r.chatter_level === 'any' || r.chatter_level === ctx.chatterLevel;
  return matchEvent && matchPattern && matchMode && matchChat;
}

const cueIx: Record<string, number> = {};
function nextCue(cues: string[]|undefined, preferTempo=false){
  if (!cues?.length) return '';
  const pool = preferTempo ? cues.filter(c=>/tempo|cadence|pace|breath/i.test(c)) : cues;
  const usable = pool.length ? pool : cues;
  const idx = (cueIx._ = ((cueIx._ ?? -1) + 1) % usable.length);
  return usable[idx];
}

function renderTemplate(tpl: string, ctx: TimelineContext, ev: Event): string {
  const exId = (ev as any).exerciseId as string | undefined;
  const meta = exId && ctx.getExerciseMeta ? ctx.getExerciseMeta(exId) : undefined;

  const setNum = typeof (ev as any).setIndex === 'number' ? ((ev as any).setIndex + 1) : '';
  const roundNum = typeof (ev as any).roundIndex === 'number' ? ((ev as any).roundIndex + 1) : '';

  const tokens: Record<string, string | number> = {
    exercise: exId ? (meta?.name ?? ctx.getExerciseName(exId)) : '',
    next: ctx.getNextExerciseName ? (ctx.getNextExerciseName() || '') : '',
    restSec: (ev as any).sec ?? '',
    cue: nextCue(meta?.cues, false),
    tempoCue: nextCue(meta?.cues, true),
    setNum,
    roundNum
  };
  return tpl.replace(/\{\{(\w+)\}\}/g, (_, k) => String(tokens[k] ?? ''));
}

export function selectResponse(ctx: TimelineContext, ev: Event): string | null {
  const now = ctx.nowMs();
  const candidates = _pool.filter(r => fit(r, ctx, ev) && !inCooldown(r, now));
  if (!candidates.length) return null;
  candidates.sort((a,b)=> (b.priority - a.priority) || (a.usage_count - b.usage_count));
  const pick = candidates[0];
  pick.usage_count += 1;
  pick.last_used_at = now;
  return renderTemplate(pick.text_template, ctx, ev);
}
